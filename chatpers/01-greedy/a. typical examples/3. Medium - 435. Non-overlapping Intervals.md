# 435. Non-overlapping Intervals  
**Tags:** Greedy, Sorting, Intervals  

---

## Problem Description  

Given an array of intervals `intervals` where `intervals[i] = [start_i, end_i]`,  
return the **minimum number of intervals** you need to remove to make the rest of the intervals non-overlapping.  

Note:  
Intervals that only touch at a single point are considered **non-overlapping**.  
For example, `[1,2]` and `[2,3]` do **not** overlap.

---

## 中文题意  

给定若干闭区间 `intervals[i] = [start_i, end_i]`，  
请计算**最少需要移除多少个区间**，  
使得剩下的区间互不重叠（两个区间端点相接视为不重叠）。  

---

## Example 1  

**Input:**  
`intervals = [[1,2],[2,3],[3,4],[1,3]]`  
**Output:**  
`1`  

**Explanation:**  
Remove `[1,3]`, and the rest are non-overlapping: `[1,2], [2,3], [3,4]`.

---

## Example 2  

**Input:**  
`intervals = [[1,2],[1,2],[1,2]]`  
**Output:**  
`2`  

**Explanation:**  
We need to remove two `[1,2]` intervals to make the rest non-overlapping.

---

## Example 3  

**Input:**  
`intervals = [[1,2],[2,3]]`  
**Output:**  
`0`  

**Explanation:**  
All intervals are already non-overlapping.

---

## Constraints  

- `1 <= intervals.length <= 10^5`  
- `intervals[i].length == 2`  
- `-5 * 10^4 <= start_i < end_i <= 5 * 10^4`

---

## Solution (Greedy — Sort by End Time)  

**Algorithm Idea:**  
This problem is a classic **Interval Scheduling Optimization**.  
To minimize removals, we can instead **maximize the number of non-overlapping intervals kept**.  

Steps:  
1. Sort intervals by their **end time** in ascending order.  
2. Initialize `prev_end` with the end of the first interval.  
3. Traverse all intervals:
   - If `start >= prev_end`, it means no overlap → **keep it**, update `prev_end = end`.  
   - Else, overlap occurs → **remove this interval** (since it ends later).  
4. Return the total number of removed intervals.  

This ensures the earliest finishing intervals are kept,  
leaving more space for future ones — a standard greedy argument for optimality.  

---

### Python Code  

```python
from typing import List

class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        if not intervals:
            return 0
        
        # Step 1: Sort by end time
        intervals.sort(key=lambda x: x[1])

        removed = 0
        prev_end = intervals[0][1]

        # Step 2: Traverse intervals
        for i in range(1, len(intervals)):
            start, end = intervals[i]
            if start >= prev_end:
                # Non-overlapping → keep it
                prev_end = end
            else:
                # Overlapping → remove current one
                removed += 1

        return removed
