# 455. Assign Cookies  
**Difficulty:** ğŸŸ¢ Easy  
**Tags:** Greedy, Sorting, Two Pointers  

---

## Problem Description  

Assume you are an awesome parent and want to give your children some cookies.  
But you should give each child at most one cookie.

Each child `i` has a greed factor `g[i]`, which is the minimum size of a cookie that the child will be content with;  
and each cookie `j` has a size `s[j]`.  
If `s[j] >= g[i]`, we can assign the cookie `j` to the child `i`,  
and the child `i` will be content.  

Your goal is to maximize the number of your content children and output the maximum number.

---

## ä¸­æ–‡é¢˜æ„  

ä½ æ˜¯ä¸€ä½å¥½å®¶é•¿ï¼Œæƒ³ç»™å­©å­ä»¬å‘é¥¼å¹²ã€‚  
æ¯ä¸ªå­©å­æœ‰ä¸€ä¸ª**é¥¥é¥¿åº¦** `g[i]`ï¼Œæ¯å—é¥¼å¹²æœ‰ä¸€ä¸ª**å¤§å°** `s[j]`ã€‚  
åªæœ‰å½“ `s[j] >= g[i]` æ—¶ï¼Œè¿™ä¸ªå­©å­æ‰ä¼šè¢«æ»¡è¶³ã€‚  
æ¯ä¸ªå­©å­æœ€å¤šå¾—åˆ°ä¸€å—é¥¼å¹²ã€‚  

æ±‚æœ€å¤šèƒ½æ»¡è¶³å¤šå°‘ä¸ªå­©å­ã€‚

---

## Example 1  

**Input:**  
`g = [1,2,3], s = [1,1]`  
**Output:**  
`1`  

**Explanation:**  
You have 3 children and 2 cookies.  
The greed factors of children are `1, 2, 3`.  
Both cookies are size 1, so only the first child can be satisfied.  
Hence the output is `1`.

---

## Example 2  

**Input:**  
`g = [1,2], s = [1,2,3]`  
**Output:**  
`2`  

**Explanation:**  
You have 2 children and 3 cookies.  
Their greed factors are `1, 2`, and cookie sizes are enough for both.  
Hence the output is `2`.

---

## Constraints  

- `1 <= g.length <= 3 * 10^4`  
- `0 <= s.length <= 3 * 10^4`  
- `1 <= g[i], s[j] <= 2^31 - 1`

---

## Solution (Greedy Approach)  

**Algorithm Idea:**  
1. Sort both arrays `g` (childrenâ€™s greed) and `s` (cookiesâ€™ size).  
2. Use **two pointers** `i` and `j` to track children and cookies.  
3. If `s[j]` can satisfy `g[i]`, assign and move both pointers.  
4. Otherwise, move cookie pointer forward until found a big enough one.  

**Python Code:**  

```python
def findContentChildren(g: list[int], s: list[int]) -> int:
    g.sort()
    s.sort()
    child_i = cookie_i = 0
    n_children, n_cookies = len(g), len(s)

    while child_i < n_children and cookie_i < n_cookies:
        if g[child_i] <= s[cookie_i]:
            child_i += 1
        cookie_i += 1
    return child_i
